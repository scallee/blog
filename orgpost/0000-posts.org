#+HUGO_BASE_DIR: ../
#+SEQ_TODO: TODO DRAFT DONE
#+PROPERTY: header-args :eval no

* INBOX

** DONE JavaScript —— this 绑定                           :JavaScript:@计算机:
   CLOSED: [2017-11-14 Tue 14:39]
   :PROPERTIES:
   :EXPORT_FILE_NAME: javascript-this
   :END:

Google 搜索出来的两个不错的链接：

- [[https://jeffjade.com/2015/08/03/2015-08-03-javascript-this/][JavaScript 之 this 详解 | 晚晴幽草轩]]
- [[https://segmentfault.com/a/1190000003046071][JS 中 this 关键字详解 - JSer - SegmentFault]]


我是先阅读的 [[https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes][You-Dont-Know-JS: this & Object Prototypes]] 。再回过头看上面的那两篇文章，我觉得他们讲解的太复杂了，而 《You-Dont-Know-JS》 就归纳的非常好。

<!--more-->

以下是总结笔记：

JS 中的 =this= 总是指向一个对象 (Object)，这个对象是基于函数运行时 *动态绑定* 的。要判断 =this= 的绑定对象，首先找到这个函数的直接调用位置，然后应用下面四条规则来判断：

1. （new 绑定）由 =new= 调用？绑定到新创建的对象。
2. （强制绑定）由 =call= 或者 =apply= （或者 =bind= ）调用？绑定到指定的对象。
3. （隐式绑定）由上下文对象调用？绑定到那个上下文对象。
4. （默认绑定）在严格模式下绑定到 =undefined= ，否则绑定到全局对象。

例外，ES6 中的箭头函数会继承外层函数调用的 =this= 绑定。（和 ES6 之前代码中的 ~self = this~ 机制一样）

*** 默认绑定
#+BEGIN_SRC javascript
function foo() {
	console.log( this.a );
}

var a = 2;

foo(); // 输出 2
// 绑定到全局对象 a， 如果是严格模式，绑定到 undefined
#+END_SRC

*** 隐式绑定
#+BEGIN_SRC javascript
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

obj.foo(); // 输出 2
// 由对象 obj 调用，绑定到 obj
#+END_SRC

*** 注意：隐式绑定的丢失问题
#+BEGIN_SRC js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

var bar = obj.foo; // 注意这个引用！

var a = "oops, global"; // 全局对象 a

bar(); // 输出： "oops, global" 绑定丢失！

setTimeout( obj.foo, 100 ); // 输出： "oops, global" 绑定丢失！
#+END_SRC

*** 强制绑定： apply, call, bind
#+BEGIN_SRC js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

var bar = function() {
	foo.call( obj ); // 将 foo 的 this 强制绑定到对象 obj
};

bar(); // 输出：2
setTimeout( bar, 100 ); // 输出： 2

// 强制绑定的对象无法被覆盖
bar.call( window ); // 2
#+END_SRC

*** new 绑定
#+BEGIN_SRC js
function foo(a) {
	this.a = a;
}

var bar = new foo( 2 ); // 使用 new 绑定到对象 bar
console.log( bar.a ); // 输出 2
#+END_SRC


** TODO 博客写作流程之工具篇： emacs, orgmode & hugo               :@计算机:
:PROPERTIES:
:EXPORT_FILE_NAME: 00-emacs-orgmode-and-hugo-write-blog-flow
:END:

本文将对我个人的博文写作流程 *所用到的工具* 做一个总结与分享。从标题就可以看出来，主要有这几个工具： emacs, orgmode & hugo 。

如果没记错的话，我最早接触博客是在 2010 年从新浪博客开始的，后面几年辗转过好几个平台，但实际上没有写多少内容，那些有限的内容删的删、忘的忘，就好像没存在过一样。有时候，我自己也是很矛盾的人，有话想说，却又觉得没多少价值，有点儿担心自己是不是在制造信息垃圾呢？有时候，又有点儿虚荣心，希望自己写的东西，被人看见。可一旦那股热乎劲儿过去了，就不了了之了。但过了一段时间，又憋的难受，总想说点什么。

这几年，看着一个个平台的流行到衰微，看着有些人被封杀，或者不再发表内容，看着一个个独立博客关闭，或者转移到微信公众号，至于这背后真正发生了什么，我不了解。也许这个世界越来越急功近利了，越来越趋于娱乐化了？

我只是知道，我有话要说，有内容想分享，仅此而已。作为一个不是专业程序员，却又喜欢折腾代码的人，搭建一个属于自己的平台，只是小事一桩。这或许是对独立与自由的追求吧。

做点有趣、有料的事儿。
这几年，自己在做事、以及对待生活的心态上有了些许变化，也许是成熟了些吧。有些东西也不太在乎了


** 博客生成工具： hugo

** 博文写作工具： emacs + orgmode

** 博文发布


** TODO 现代 JavaScript 开发流程简介

   
